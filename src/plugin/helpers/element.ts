import type { DOMSerializer, Node, Schema } from "prosemirror-model";
import type { FieldValidationErrors } from "../elementSpec";
import type { FieldNameToValueMap } from "../fieldViews/helpers";
import { fieldTypeToViewMap } from "../fieldViews/helpers";
import { createNodesForFieldValues, getFieldNameFromNode } from "../nodeSpec";
import type {
  ElementSpecMap,
  ExtractDataTypeFromElementSpec,
  FieldDescription,
  FieldDescriptions,
  FieldNameToField,
} from "../types/Element";

/**
 * Creates a function that will attempt to create a Prosemirror node from
 * the given element data. If it does not recognise the element type,
 * returns undefined.
 */
export const createGetNodeFromElementData = <
  FDesc extends FieldDescriptions<keyof FDesc>,
  ElementNames extends keyof ESpecMap,
  ESpecMap extends ElementSpecMap<FDesc, ElementNames>
>(
  elementTypeMap: ESpecMap
) => (
  {
    elementName,
    values,
  }: {
    elementName: string;
    values: unknown;
  },
  schema: Schema
) => {
  const element = elementTypeMap[elementName as keyof ESpecMap];

  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- this may be falsy.
  if (!element) {
    return undefined;
  }

  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- we cannot be sure the schema has been amended
  if (!schema.nodes[elementName]) {
    throw new Error(
      `[prosemirror-elements]: ${elementName} is not included in the state schema. Did you add the NodeSpec generated by this plugin to the schema?`
    );
  }

  const nodes = createNodesForFieldValues(
    schema,
    element.fieldDescriptions,
    values as FieldNameToValueMap<FDesc>,
    elementName
  );

  return schema.nodes[elementName].createAndFill(
    {
      type: elementName,
    },
    nodes
  );
};

/**
 * Creates a function that will attempt to extract element data from
 * the given node. If it does not recognise the node as an element,
 * returns undefined.
 */
export const createGetElementDataFromNode = <
  FDesc extends FieldDescriptions<keyof FDesc>,
  ElementNames extends keyof ESpecMap,
  ESpecMap extends ElementSpecMap<FDesc, ElementNames>
>(
  elementTypeMap: ESpecMap
) => (node: Node, serializer: DOMSerializer) => {
  const elementName = node.attrs.type as ElementNames;
  const element = elementTypeMap[elementName];

  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- this may be falsy.
  if (!element) {
    return undefined;
  }

  // We gather the values from each child as we iterate over the
  // node, to update the renderer. It's difficult to be typesafe here,
  // as the Node's name value is loosely typed as `string`, and so we
  // cannot index into the element `fieldDescriptions` to discover the appropriate type.
  const values: Record<string, unknown> = {};
  node.forEach((node) => {
    const fieldName = getFieldNameFromNode(
      node
    ) as keyof FieldNameToField<FDesc>;
    const fieldDescription = element.fieldDescriptions[fieldName];
    const value = getValuesFromNode(node, fieldDescription, serializer);

    if (
      (fieldDescription.type === "richText" ||
        fieldDescription.type === "text") &&
      fieldDescription.absentOnEmpty &&
      !node.textContent
    ) {
      return;
    }

    values[fieldName] = value;
  });

  return {
    elementName,
    values,
  } as ExtractDataTypeFromElementSpec<ESpecMap, ElementNames>;
};

const getValuesFromNode = (
  node: Node,
  fieldDescription: FieldDescription,
  serializer: DOMSerializer
): unknown => {
  const fieldType = fieldTypeToViewMap[fieldDescription.type].fieldType;
  if (fieldType === "ATTRIBUTES") {
    return getValuesFromAttributeNode(node);
  }
  if (fieldDescription.type === "richText") {
    return getValuesFromRichContentNode(node, serializer);
  }
  if (fieldDescription.type === "text") {
    return getValuesFromTextContentNode(node);
  }
  return undefined;
};

const getValuesFromAttributeNode = (node: Node) => node.attrs.fields as unknown;

const getValuesFromRichContentNode = (
  node: Node,
  serializer: DOMSerializer
) => {
  const dom = serializer.serializeFragment(node.content);
  const e = document.createElement("div");
  e.appendChild(dom);
  return e.innerHTML;
};

const getValuesFromTextContentNode = (node: Node) => node.textContent;

export const createElementDataValidator = <
  FDesc extends FieldDescriptions<keyof FDesc>,
  ElementNames extends keyof ESpec,
  ESpec extends ElementSpecMap<FDesc, ElementNames>
>(
  elementTypeMap: ESpec
) => ({
  elementName,
  values,
}: ExtractDataTypeFromElementSpec<ESpec, ElementNames>):
  | FieldValidationErrors
  | undefined => {
  const element = elementTypeMap[elementName];

  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- this may be falsy.
  if (!element) {
    return undefined;
  }

  const data = (values as unknown) as FieldNameToValueMap<FDesc>;

  return element.validate(data);
};
