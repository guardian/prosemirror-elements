import type { DOMSerializer, Node, Schema } from "prosemirror-model";
import type { FieldNameToValueMap } from "../fieldViews/helpers";
import { fieldTypeToViewMap } from "../fieldViews/helpers";
import { createNodesForFieldValues } from "../nodeSpec";
import type {
  ElementSpec,
  FieldNameToFieldViewSpec,
  FieldSpec,
} from "../types/Element";

export const createGetNodeFromElement = <
  FSpec extends FieldSpec<string>,
  ElementNames extends string
>(
  elementTypeMap: Partial<{ [elementName in ElementNames]: ElementSpec<FSpec> }>
) => (
  elementName: ElementNames,
  fieldValues: Partial<FieldNameToValueMap<FSpec>> = {},
  schema: Schema
) => {
  const element = elementTypeMap[elementName];
  if (!element) {
    throw new Error(
      `[prosemirror-elements]: ${elementName} is not recognised. Only ${Object.keys(
        elementTypeMap
      ).join(", ")} can be added`
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- we cannot be sure the schema has been amended
  if (!schema.nodes[elementName]) {
    throw new Error(
      `[prosemirror-elements]: ${elementName} is not included in the state schema. Did you add the NodeSpec generated by this plugin to the schema?`
    );
  }

  const nodes = createNodesForFieldValues(
    schema,
    element.fieldSpec,
    fieldValues,
    elementName
  );

  return schema.nodes[elementName].createAndFill(
    {
      type: elementName,
    },
    nodes
  );
};

export const createGetElementFromNode = <
  FSpec extends FieldSpec<string>,
  ElementNames extends string
>(
  elementTypeMap: Partial<{ [elementName in ElementNames]: ElementSpec<FSpec> }>
) => (node: Node, serializer: DOMSerializer) => {
  const nodeType = node.attrs.type as ElementNames;
  const elementSpec = elementTypeMap[nodeType];

  if (!elementSpec) {
    return undefined;
  }

  // We gather the values from each child as we iterate over the
  // node, to update the renderer. It's difficult to be typesafe here,
  // as the Node's name value is loosely typed as `string`, and so we
  // cannot index into the element `fieldSpec` to discover the appropriate type.
  const fieldValues: Record<string, unknown> = {};
  node.forEach((node) => {
    const fieldName = node.type.name as keyof FieldNameToFieldViewSpec<FSpec>;
    const fieldSpec = elementSpec.fieldSpec[fieldName];
    const fieldType = fieldTypeToViewMap[fieldSpec.type].fieldType;

    fieldValues[fieldName] =
      fieldType === "ATTRIBUTES"
        ? getValuesFromAttributeNode(node)
        : getValuesFromContentNode(node, serializer);
  });

  return fieldValues as FieldNameToValueMap<FSpec>;
};

const getValuesFromAttributeNode = (node: Node) => node.attrs.fields as unknown;

const getValuesFromContentNode = (node: Node, serializer: DOMSerializer) => {
  const dom = serializer.serializeFragment(node.content);
  const e = document.createElement("div");
  e.appendChild(dom);
  return e.innerHTML;
};
