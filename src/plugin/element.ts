import OrderedMap from "orderedmap";
import type { NodeSpec, Schema } from "prosemirror-model";
import type { EditorState, Transaction } from "prosemirror-state";
import type { FieldNameToValueMap } from "./fieldViews/helpers";
import { buildCommands, defaultPredicate } from "./helpers/prosemirror";
import { createNodesForFieldValues } from "./nodeSpec";
import { createPlugin } from "./plugin";
import type {
  ElementSpec,
  FieldSpec,
  UnnamedElementSpec,
  UnnamedElementSpecMap,
} from "./types/Element";

type ExtractFieldValues<UESpec> = Partial<
  UESpec extends UnnamedElementSpec<infer F> ? FieldNameToValueMap<F> : never
>;

type ExtractESpecMap<UESpecMap> = UESpecMap extends UnnamedElementSpecMap<
  FieldSpec<string>,
  keyof UESpecMap
>
  ? {
      [Name in keyof UESpecMap]: ExtractESpec<UESpecMap[Name], Name>;
    }
  : never;

type ExtractESpec<
  UESpec,
  Name extends string
> = UESpec extends UnnamedElementSpec<infer F> ? ElementSpec<F> : never;

const getElementSpecMap = <
  FSpec extends FieldSpec<keyof FSpec>,
  ElementNames extends keyof UESpecs,
  UESpecs extends UnnamedElementSpecMap<FSpec, ElementNames>
>(
  unnamedElementSpecMap: UESpecs
) => {
  const elementSpecMap = {} as ExtractESpecMap<UESpecs>;

  for (const elementName in unnamedElementSpecMap) {
    // Typescript is unable to tell that `elementName` shares an index type between
    // `elementSpecMap` and `unnamedElementSpecMap`. This may be a bug. Issue here:
    //
    // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error, @typescript-eslint/ban-ts-comment -- as above
    // @ts-ignore
    elementSpecMap[elementName] = unnamedElementSpecMap[elementName](
      elementName
    );
  }

  return elementSpecMap;
};

/**
 * Build an element plugin with the given element specs, along with the schema required
 * by those elements, and a method to insert elements into the document.
 */
export const buildElementPlugin = <
  FSpec extends FieldSpec<keyof FSpec>,
  ElementNames extends keyof UESpecs,
  UESpecs extends UnnamedElementSpecMap<FSpec, ElementNames>
>(
  unnamedElementSpecs: UESpecs,
  predicate = defaultPredicate
) => {
  const elementSpecs = getElementSpecMap(unnamedElementSpecs);
  const insertElement = <Name extends ElementNames>(
    type: Extract<Name, string>,
    fieldValues: ExtractFieldValues<UESpecs[Name]> = {}
  ) => (
    state: EditorState,
    dispatch: (tr: Transaction<Schema>) => void
  ): void => {
    const element = elementSpecs[type];
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Typescript trusts our consumers to pass a correct element type, but we don't :)
    if (!element) {
      throw new Error(
        `[prosemirror-elements]: ${type} is not recognised. Only ${Object.keys(
          elementSpecs
        ).join(", ")} can be added`
      );
    }
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- we cannot be sure the schema has been amended
    if (!(state.schema as Schema).nodes[type]) {
      throw new Error(
        `[prosemirror-elements]: ${type} is not included in the state schema. Did you add the NodeSpec generated by this plugin to the schema?`
      );
    }

    const nodes = createNodesForFieldValues(
      state.schema,
      element.fieldSpec,
      fieldValues
    );

    const maybeNewNode = (state.schema as Schema).nodes[type].createAndFill(
      {
        type,
      },
      nodes
    );
    if (maybeNewNode) {
      dispatch(state.tr.replaceSelectionWith(maybeNewNode));
    } else {
      console.warn(
        `[prosemirror-elements]: Could not create a node for ${type}`
      );
    }
  };

  const plugin = createPlugin(elementSpecs, buildCommands(predicate));
  let nodeSpec: OrderedMap<NodeSpec> = OrderedMap.from({});
  for (const elementName in elementSpecs) {
    nodeSpec = nodeSpec.append(elementSpecs[elementName].nodeSpec);
  }

  return {
    insertElement,
    hasErrors: (state: EditorState) => plugin.getState(state).hasErrors,
    plugin,
    nodeSpec,
  };
};
