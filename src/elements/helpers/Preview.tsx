import { css } from "@emotion/react";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Description } from "../../editorial-source-components/Description";
import type { DemoInputHeadingProps } from "../../editorial-source-components/DemoInputHeading";
import { DemoInputHeading } from "../../editorial-source-components/DemoInputHeading";
import { hasOwnProperty } from "./hasOwnProperty";

type PreviewProps = Partial<DemoInputHeadingProps> & {
  html?: string;
  iframeUrl?: string;
  minHeight?: number;
};

type MessageData = {
  value: number;
  type: string;
};

const iframe = css`
  background-color: white;
  width: 100%;
  font-family: sans-serif;
`;

const crossDomainIframe = css`
  background-color: white;
  width: 100%;
  font-family: sans-serif;
  resize: vertical;
`;

const getDocHeight = (doc: Document | undefined) => {
  if (doc) {
    const body = doc.body;
    const html = doc.documentElement;
    const height = Math.max(
      body.scrollHeight,
      body.offsetHeight,
      html.offsetHeight
    );
    return height;
  }
  return undefined;
};

const isMessageData = (data: unknown): data is MessageData =>
  typeof data === "object" &&
  data !== null &&
  hasOwnProperty(data, "value") &&
  hasOwnProperty(data, "type") &&
  typeof data.value === "number" &&
  typeof data.type === "string";

// Prevent scrollbar appearing due to iframe size issue
const extraPreviewSpace = 4;
// Only allow the preview to occupy this proportion of space relative to the viewport height.
const maxHeightRelativeToViewport = 0.5;

const hasInnerText = (html: string) => {
  const div = document.createElement("div");
  div.innerHTML = html;
  return !!div.innerText.trim().length;
};

export const Preview = ({
  html,
  iframeUrl,
  headingLabel = "Preview",
  minHeight,
  ...rest
}: PreviewProps) => {
  const [height, setHeight] = useState("0px");

  const ref = useRef<HTMLIFrameElement>(null);

  const setIdealHeight = (height: number) => {
    let idealHeight =
      Math.min(height, window.innerHeight * maxHeightRelativeToViewport) +
      extraPreviewSpace;

    idealHeight = minHeight ? Math.max(minHeight, idealHeight) : idealHeight;

    setHeight(`${idealHeight}px`);
  };

  const updateIframeHeight = () => {
    const heightOfContent = getDocHeight(ref.current?.contentWindow?.document);
    if (heightOfContent) {
      setIdealHeight(heightOfContent);
    }
  };

  const listener = useCallback(
    (message: MessageEvent) => {
      try {
        const data = JSON.parse(message.data) as unknown;
        if (
          isMessageData(data) &&
          data.type === "set-height" &&
          ref.current &&
          ref.current.contentWindow === message.source
        ) {
          const height = data.value;
          setIdealHeight(height);
        }
      } catch (e) {
        // Catch JSON parse errors generated by other messages
      }
    },
    [setHeight]
  );

  const onLoad = () => {
    updateIframeHeight();
    setTimeout(() => {
      updateIframeHeight();
    }, 1000);
  };

  const onInteractiveLoad = () => {
    setHeight("200px;");
  };

  useEffect(() => {
    window.addEventListener("message", listener);
    return () => {
      window.removeEventListener("message", listener);
    };
  }, []);

  const showPreviewHtml = useMemo(() => !!html && hasInnerText(html), [html]);

  let preview = null;

  if (iframeUrl) {
    preview = (
      <iframe
        src={iframeUrl}
        css={crossDomainIframe}
        height={height}
        ref={ref}
        onLoad={onInteractiveLoad}
      />
    );
  } else if (showPreviewHtml) {
    preview = (
      <iframe
        srcDoc={html}
        css={iframe}
        height={height}
        ref={ref}
        onLoad={onLoad}
        id="myFrame"
      />
    );
  } else {
    preview = <Description>No preview available.</Description>;
  }

  return (
    <div>
      {headingLabel && <DemoInputHeading headingLabel={headingLabel} {...rest} />}
      {preview}
    </div>
  );
};
